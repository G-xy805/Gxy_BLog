---
title: 15.å¤šçº¿ç¨‹é‡Œçº¿ç¨‹çš„åŒæ­¥æ–¹å¼æœ‰å“ªäº›
order: 15
description: è¯¦è§£C++å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­å¸¸ç”¨çš„çº¿ç¨‹åŒæ­¥æ–¹å¼ï¼ŒåŒ…æ‹¬äº’æ–¥é”ã€ä¿¡å·é‡ã€æ¡ä»¶å˜é‡ç­‰æœºåˆ¶çš„åŸç†å’Œä½¿ç”¨åœºæ™¯
published: 2026-01-23
image: /assets/images/cpp-logo.webp
tags:
- å¤šçº¿ç¨‹
- å¹¶å‘
- åŒæ­¥æœºåˆ¶
category: C++
---
# ğŸ”¬ å¤šçº¿ç¨‹åŒæ­¥æœºåˆ¶è¯¦è§£
## ğŸ“– å†…å®¹æ¦‚è§ˆ

æœ¬æ–‡è¯¦ç»†ä»‹ç»C++å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­å¸¸ç”¨çš„çº¿ç¨‹åŒæ­¥æ–¹å¼ï¼ŒåŒ…æ‹¬äº’æ–¥é”ã€ä¿¡å·é‡ã€æ¡ä»¶å˜é‡ã€å±éšœã€è¯»å†™é”ã€è‡ªæ—‹é”å’ŒåŸå­æ“ä½œç­‰æœºåˆ¶ï¼Œåˆ†æå®ƒä»¬çš„å·¥ä½œåŸç†ã€é€‚ç”¨åœºæ™¯ã€ä¼˜ç¼ºç‚¹ï¼Œå¹¶é€šè¿‡ä»£ç ç¤ºä¾‹æ¼”ç¤ºå…·ä½“ä½¿ç”¨æ–¹æ³•ã€‚
## ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

### âœ¨ çº¿ç¨‹åŒæ­¥çš„å¿…è¦æ€§
åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®å…±äº«èµ„æºå¯èƒ½å¯¼è‡´æ•°æ®ç«äº‰ï¼ˆRace Conditionï¼‰ï¼Œä»è€Œäº§ç”Ÿä¸å¯é¢„æµ‹çš„ç»“æœã€‚çº¿ç¨‹åŒæ­¥æœºåˆ¶çš„ç›®çš„æ˜¯ç¡®ä¿å¤šä¸ªçº¿ç¨‹èƒ½å¤Ÿå®‰å…¨åœ°è®¿é—®å…±äº«èµ„æºï¼Œé¿å…æ•°æ®ä¸ä¸€è‡´å’Œç¨‹åºå´©æºƒã€‚
### ğŸ”§ åŒæ­¥æ–¹å¼åˆ†ç±»
C++ä¸­å¸¸ç”¨çš„çº¿ç¨‹åŒæ­¥æ–¹å¼åŒ…æ‹¬ï¼š
1. **äº’æ–¥é”ï¼ˆMutexï¼‰**ï¼šä¿æŠ¤ä¸´ç•ŒåŒºï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹è®¿é—®
2. **ä¿¡å·é‡ï¼ˆSemaphoreï¼‰**ï¼šæ§åˆ¶åŒæ—¶è®¿é—®èµ„æºçš„çº¿ç¨‹æ•°é‡
3. **æ¡ä»¶å˜é‡ï¼ˆCondition Variableï¼‰**ï¼šç­‰å¾…ç‰¹å®šæ¡ä»¶æ»¡è¶³
4. **å±éšœï¼ˆBarrierï¼‰**ï¼šåè°ƒå¤šä¸ªçº¿ç¨‹çš„æ‰§è¡Œé¡ºåº
5. **è¯»å†™é”ï¼ˆRead-Write Lockï¼‰**ï¼šåŒºåˆ†è¯»å†™æ“ä½œï¼Œä¼˜åŒ–å¹¶å‘æ€§èƒ½
6. **è‡ªæ—‹é”ï¼ˆSpin Lockï¼‰**ï¼šé¿å…ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€
7. **åŸå­æ“ä½œï¼ˆAtomic Operationï¼‰**ï¼šæ— é”åŒæ­¥æœºåˆ¶
## ğŸ” è¯¦ç»†ä»‹ç»

### ğŸ›¡ï¸ äº’æ–¥é”ï¼ˆMutexï¼‰
**åŸºæœ¬æ¦‚å¿µ**ï¼šäº’æ–¥é”æ˜¯æœ€å¸¸ç”¨çš„åŒæ­¥æœºåˆ¶ï¼Œç”¨äºä¿æŠ¤ä¸´ç•ŒåŒºï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿›å…¥ä¸´ç•ŒåŒºã€‚
**å·¥ä½œåŸç†**ï¼šçº¿ç¨‹åœ¨è¿›å…¥ä¸´ç•ŒåŒºå‰è·å–é”ï¼Œç¦»å¼€æ—¶é‡Šæ”¾é”ã€‚å¦‚æœé”å·²è¢«å…¶ä»–çº¿ç¨‹å ç”¨ï¼Œå½“å‰çº¿ç¨‹ä¼šé˜»å¡ç­‰å¾…ã€‚
**é€‚ç”¨åœºæ™¯**ï¼šä¿æŠ¤å…±äº«æ•°æ®ï¼Œé¿å…å¤šä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹
**ä»£ç ç¤ºä¾‹**ï¼š
```cpp
#include <iostream>
#include <thread>
#include <mutex>
std::mutex mtx;
int shared_data = 0;
void increment() {
    for (int i = 0; i < 10000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);  // è‡ªåŠ¨åŠ é”å’Œè§£é”
        shared_data++;
    }
}
int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    
    t1.join();
    t2.join();
    std::cout << "å…±äº«æ•°æ®æœ€ç»ˆå€¼: " << shared_data << std::endl;
    return 0;
```
### ğŸ“Š ä¿¡å·é‡ï¼ˆSemaphoreï¼‰
**åŸºæœ¬æ¦‚å¿µ**ï¼šä¿¡å·é‡æ˜¯ä¸€ç§è®¡æ•°å™¨ï¼Œç”¨äºæ§åˆ¶åŒæ—¶è®¿é—®ç‰¹å®šèµ„æºçš„çº¿ç¨‹æ•°é‡ã€‚
**å·¥ä½œåŸç†**ï¼šçº¿ç¨‹åœ¨è®¿é—®èµ„æºå‰è·å–ä¿¡å·é‡ï¼ˆè®¡æ•°å™¨å‡1ï¼‰ï¼Œè®¿é—®å®Œæ¯•åé‡Šæ”¾ä¿¡å·é‡ï¼ˆè®¡æ•°å™¨åŠ 1ï¼‰ã€‚å½“è®¡æ•°å™¨ä¸º0æ—¶ï¼Œåç»­çº¿ç¨‹ä¼šé˜»å¡ç­‰å¾…ã€‚
**é€‚ç”¨åœºæ™¯**ï¼šé™åˆ¶å¹¶å‘è®¿é—®çš„çº¿ç¨‹æ•°é‡ï¼Œå¦‚è¿æ¥æ± ã€èµ„æºæ± 
```cpp
#include <iostream>
#include <thread>
#include <semaphore>
#include <vector>
#include <chrono>
std::counting_semaphore<3> sem(3);  // æœ€å¤šå…è®¸3ä¸ªçº¿ç¨‹åŒæ—¶è®¿é—®
void worker(int id) {
    sem.acquire();  // è·å–ä¿¡å·é‡
    std::cout << "çº¿ç¨‹ " << id << " å¼€å§‹å·¥ä½œ" << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "çº¿ç¨‹ " << id << " å®Œæˆå·¥ä½œ" << std::endl;
    sem.release();  // é‡Šæ”¾ä¿¡å·é‡
    std::vector<std::thread> threads;
    for (int i = 0; i < 5; ++i) {
        threads.emplace_back(worker, i);
    }
    for (auto& t : threads) {
        t.join();
    }
    return 0;
}
```
### ğŸ”„ æ¡ä»¶å˜é‡ï¼ˆCondition Variableï¼‰
**åŸºæœ¬æ¦‚å¿µ**ï¼šæ¡ä»¶å˜é‡ç”¨äºçº¿ç¨‹é—´çš„é€šä¿¡ï¼Œå…è®¸çº¿ç¨‹ç­‰å¾…ç‰¹å®šæ¡ä»¶æ»¡è¶³åå†ç»§ç»­æ‰§è¡Œã€‚
**å·¥ä½œåŸç†**ï¼šçº¿ç¨‹åœ¨æ¡ä»¶ä¸æ»¡è¶³æ—¶è°ƒç”¨wait()è¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œå…¶ä»–çº¿ç¨‹åœ¨æ¡ä»¶æ»¡è¶³æ—¶è°ƒç”¨notify_one()æˆ–notify_all()å”¤é†’ç­‰å¾…çº¿ç¨‹ã€‚
**é€‚ç”¨åœºæ™¯**ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€çº¿ç¨‹åä½œå®Œæˆä»»åŠ¡
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
#include <chrono>
std::condition_variable cv;
std::queue<int> data_queue;
bool done = false;
void producer() {
    for (int i = 0; i < 10; ++i) {
        {   // ä¸´ç•ŒåŒºå¼€å§‹
            std::lock_guard<std::mutex> lock(mtx);
            data_queue.push(i);
            std::cout << "ç”Ÿäº§æ•°æ®: " << i << std::endl;
        }   // ä¸´ç•ŒåŒºç»“æŸ
        cv.notify_one();  // é€šçŸ¥ç­‰å¾…çš„æ¶ˆè´¹è€…
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    {   // ä¸´ç•ŒåŒºå¼€å§‹
        std::lock_guard<std::mutex> lock(mtx);
        done = true;
    }   // ä¸´ç•ŒåŒºç»“æŸ
    cv.notify_all();  // é€šçŸ¥æ‰€æœ‰ç­‰å¾…çš„æ¶ˆè´¹è€…
void consumer() {
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []{ return done || !data_queue.empty(); });
        
        if (done && data_queue.empty()) {
            break;
        }
        int data = data_queue.front();
        data_queue.pop();
        std::cout << "æ¶ˆè´¹æ•°æ®: " << data << std::endl;
    }
}

int main() {
    std::thread t_producer(producer);
    std::thread t_consumer(consumer);
    t_producer.join();
    t_consumer.join();
    return 0;
}
```
### ğŸ“ å±éšœï¼ˆBarrierï¼‰
**åŸºæœ¬æ¦‚å¿µ**ï¼šå±éšœç”¨äºåè°ƒå¤šä¸ªçº¿ç¨‹çš„æ‰§è¡Œï¼Œç¡®ä¿æ‰€æœ‰çº¿ç¨‹éƒ½åˆ°è¾¾å±éšœç‚¹åæ‰èƒ½ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ­¥ã€‚
**å·¥ä½œåŸç†**ï¼šæ¯ä¸ªçº¿ç¨‹åœ¨åˆ°è¾¾å±éšœç‚¹æ—¶è°ƒç”¨wait()ï¼Œå½“æ‰€æœ‰çº¿ç¨‹éƒ½è°ƒç”¨wait()åï¼Œæ‰€æœ‰çº¿ç¨‹åŒæ—¶ç»§ç»­æ‰§è¡Œã€‚
**é€‚ç”¨åœºæ™¯**ï¼šéœ€è¦æ‰€æœ‰çº¿ç¨‹å®Œæˆç‰¹å®šé˜¶æ®µåæ‰èƒ½è¿›å…¥ä¸‹ä¸€é˜¶æ®µçš„ä»»åŠ¡
```cpp
#include <iostream>
#include <thread>
#include <barrier>
#include <vector>
const int thread_count = 4;
std::barrier<> sync_point(thread_count);

void stage_worker(int id) {
    std::cout << "çº¿ç¨‹ " << id << " å®Œæˆç¬¬ä¸€é˜¶æ®µ" << std::endl;
    sync_point.arrive_and_wait();  // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆç¬¬ä¸€é˜¶æ®µ
    std::cout << "çº¿ç¨‹ " << id << " å¼€å§‹ç¬¬äºŒé˜¶æ®µ" << std::endl;
    sync_point.arrive_and_wait();  // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆç¬¬äºŒé˜¶æ®µ
    std::cout << "çº¿ç¨‹ " << id << " ä»»åŠ¡å®Œæˆ" << std::endl;
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < thread_count; ++i) {
        threads.emplace_back(stage_worker, i);
    }
    for (auto& t : threads) {
        t.join();
    }
    return 0;
}
```
### ğŸ”„ è¯»å†™é”ï¼ˆRead-Write Lockï¼‰
**åŸºæœ¬æ¦‚å¿µ**ï¼šè¯»å†™é”åŒºåˆ†è¯»æ“ä½œå’Œå†™æ“ä½œï¼Œå…è®¸å¤šä¸ªè¯»æ“ä½œåŒæ—¶è¿›è¡Œï¼Œä½†å†™æ“ä½œå¿…é¡»äº’æ–¥æ‰§è¡Œã€‚
**å·¥ä½œåŸç†**ï¼š
- è¯»é”ï¼šå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è·å–è¯»é”
- å†™é”ï¼šåªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è·å–å†™é”ï¼Œä¸”ä¸èƒ½ä¸è¯»é”å…±å­˜
**é€‚ç”¨åœºæ™¯**ï¼šè¯»å¤šå†™å°‘çš„åœºæ™¯ï¼Œå¦‚ç¼“å­˜ã€é…ç½®æ–‡ä»¶è®¿é—®
```cpp
#include <iostream>
#include <thread>
#include <shared_mutex>
#include <vector>
#include <chrono>
std::shared_mutex rw_mutex;
int shared_data = 0;

void reader(int id) {
    for (int i = 0; i < 5; ++i) {
        {   // ä¸´ç•ŒåŒºå¼€å§‹
            std::shared_lock<std::shared_mutex> lock(rw_mutex);  // è·å–è¯»é”
            std::cout << "è¯»è€… " << id << " è¯»å–æ•°æ®: " << shared_data << std::endl;
        }   // ä¸´ç•ŒåŒºç»“æŸ
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
void writer(int id) {
    for (int i = 0; i < 3; ++i) {
        {   // ä¸´ç•ŒåŒºå¼€å§‹
            std::unique_lock<std::shared_mutex> lock(rw_mutex);  // è·å–å†™é”
            shared_data++;
            std::cout << "å†™è€… " << id << " æ›´æ–°æ•°æ®ä¸º: " << shared_data << std::endl;
        }   // ä¸´ç•ŒåŒºç»“æŸ
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
}

int main() {
    std::vector<std::thread> threads;
    // åˆ›å»º3ä¸ªè¯»è€…çº¿ç¨‹
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(reader, i);
    }
    // åˆ›å»º2ä¸ªå†™è€…çº¿ç¨‹
    for (int i = 0; i < 2; ++i) {
        threads.emplace_back(writer, i);
    }
    for (auto& t : threads) {
        t.join();
    }
    return 0;
}
```
### ğŸ”„ è‡ªæ—‹é”ï¼ˆSpin Lockï¼‰
**åŸºæœ¬æ¦‚å¿µ**ï¼šè‡ªæ—‹é”åœ¨è·å–é”å¤±è´¥æ—¶ä¸ä¼šé˜»å¡ï¼Œè€Œæ˜¯ä¸æ–­å¾ªç¯æ£€æŸ¥é”æ˜¯å¦å¯ç”¨ï¼Œé¿å…äº†ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ã€‚
**å·¥ä½œåŸç†**ï¼šä½¿ç”¨åŸå­æ“ä½œå®ç°é”çš„è·å–å’Œé‡Šæ”¾ï¼Œçº¿ç¨‹åœ¨è·å–é”æ—¶è‡ªæ—‹ç­‰å¾…ã€‚
**é€‚ç”¨åœºæ™¯**ï¼šä¸´ç•ŒåŒºæ‰§è¡Œæ—¶é—´çŸ­ã€çº¿ç¨‹æ•°é‡å°‘çš„åœºæ™¯
```cpp
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>
class SpinLock {
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT;
public:
    void lock() {
        while (flag.test_and_set(std::memory_order_acquire)) {
            // è‡ªæ—‹ç­‰å¾…
        }
    }
    void unlock() {
        flag.clear(std::memory_order_release);
    }
};

SpinLock spin_lock;
int shared_data = 0;

void increment() {
    for (int i = 0; i < 10000; ++i) {
        spin_lock.lock();
        shared_data++;
        spin_lock.unlock();
    }
}

int main() {
    std::vector<std::thread> threads;
    // åˆ›å»º4ä¸ªçº¿ç¨‹
    for (int i = 0; i < 4; ++i) {
        threads.emplace_back(increment);
    }
    for (auto& t : threads) {
        t.join();
    }
    std::cout << "å…±äº«æ•°æ®æœ€ç»ˆå€¼: " << shared_data << std::endl;
    return 0;
}
```
### âš›ï¸ åŸå­æ“ä½œï¼ˆAtomic Operationï¼‰
**åŸºæœ¬æ¦‚å¿µ**ï¼šåŸå­æ“ä½œæ˜¯ä¸€ç§æ— é”åŒæ­¥æœºåˆ¶ï¼Œåœ¨å•ä¸ªCPUæŒ‡ä»¤ä¸­å®Œæˆæ•°æ®çš„è¯»å–å’Œä¿®æ”¹ï¼Œä¸ä¼šè¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ã€‚
**å·¥ä½œåŸç†**ï¼šä½¿ç”¨ç¡¬ä»¶æ”¯æŒçš„åŸå­æŒ‡ä»¤ï¼Œç¡®ä¿æ“ä½œçš„åŸå­æ€§ï¼Œæ— éœ€ä½¿ç”¨é”ã€‚
**é€‚ç”¨åœºæ™¯**ï¼šç®€å•çš„è®¡æ•°å™¨ã€æ ‡å¿—ä½ç­‰ï¼Œé¿å…é”çš„å¼€é”€
```cpp
#include <iostream>
#include <thread>
#include <atomic>

std::atomic<int> shared_data = 0;

void increment() {
    for (int i = 0; i < 10000; ++i) {
        shared_data++;
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << "å…±äº«æ•°æ®æœ€ç»ˆå€¼: " << shared_data << std::endl;
    return 0;
}
```
## ğŸ“Š åŒæ­¥æ–¹å¼å¯¹æ¯”

| åŒæ­¥æ–¹å¼ | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|----------|----------|------|------|
| **äº’æ–¥é”** | ä¿æŠ¤ä¸´ç•ŒåŒº | ç®€å•æ˜“ç”¨ | å¯èƒ½å¯¼è‡´æ­»é”ã€ä¼˜å…ˆçº§åè½¬ |
| **ä¿¡å·é‡** | æ§åˆ¶å¹¶å‘æ•°é‡ | çµæ´»æ§åˆ¶èµ„æºè®¿é—® | å®ç°å¤æ‚ï¼Œå®¹æ˜“å‡ºé”™ |
| **æ¡ä»¶å˜é‡** | çº¿ç¨‹é—´é€šä¿¡ | é«˜æ•ˆç­‰å¾…æ¡ä»¶ | å®¹æ˜“ä½¿ç”¨ä¸å½“å¯¼è‡´æ­»é” |
| **å±éšœ** | å¤šçº¿ç¨‹åè°ƒ | ç®€åŒ–çº¿ç¨‹åŒæ­¥ | ä»…é€‚ç”¨äºå›ºå®šæ•°é‡çº¿ç¨‹ |
| **è¯»å†™é”** | è¯»å¤šå†™å°‘åœºæ™¯ | æé«˜å¹¶å‘æ€§èƒ½ | å®ç°å¤æ‚ |
| **è‡ªæ—‹é”** | çŸ­ä¸´ç•ŒåŒº | é¿å…ä¸Šä¸‹æ–‡åˆ‡æ¢ | æ¶ˆè€—CPUèµ„æºï¼Œå¯èƒ½å¯¼è‡´é¥¥é¥¿ |
| **åŸå­æ“ä½œ** | ç®€å•æ•°æ®æ“ä½œ | æ— é”ï¼Œé«˜æ€§èƒ½ | ä»…é€‚ç”¨äºç®€å•æ“ä½œ |
## ğŸ› ï¸ æœ€ä½³å®è·µ

1. **ä¼˜å…ˆä½¿ç”¨åŸå­æ“ä½œ**ï¼šå¯¹äºç®€å•çš„æ•°æ®æ“ä½œï¼Œä½¿ç”¨åŸå­æ“ä½œæ¯”é”æ›´é«˜æ•ˆ
2. **é€‰æ‹©åˆé€‚çš„é”ç±»å‹**ï¼šæ ¹æ®åœºæ™¯é€‰æ‹©è¯»å†™é”ã€äº’æ–¥é”æˆ–è‡ªæ—‹é”
3. **é¿å…æ­»é”**ï¼šéµå¾ªé”çš„è·å–é¡ºåºï¼Œä½¿ç”¨RAIIç®¡ç†é”çš„ç”Ÿå‘½å‘¨æœŸ
4. **å‡å°‘ä¸´ç•ŒåŒºå¤§å°**ï¼šä¸´ç•ŒåŒºè¶Šå°ï¼Œå¹¶å‘æ€§èƒ½è¶Šé«˜
5. **ä½¿ç”¨æ¡ä»¶å˜é‡ä»£æ›¿è½®è¯¢**ï¼šç­‰å¾…æ¡ä»¶æ—¶ä½¿ç”¨æ¡ä»¶å˜é‡ï¼Œé¿å…CPUèµ„æºæµªè´¹
6. **è€ƒè™‘ä½¿ç”¨é«˜çº§åŒæ­¥æœºåˆ¶**ï¼šå¦‚std::futureã€std::promiseç­‰
## ğŸ“‹ æ€»ç»“

C++æä¾›äº†å¤šç§çº¿ç¨‹åŒæ­¥æœºåˆ¶ï¼Œæ¯ç§æœºåˆ¶éƒ½æœ‰å…¶é€‚ç”¨åœºæ™¯å’Œä¼˜ç¼ºç‚¹ã€‚åœ¨å®é™…å¼€å‘ä¸­ï¼Œéœ€è¦æ ¹æ®å…·ä½“æƒ…å†µé€‰æ‹©åˆé€‚çš„åŒæ­¥æ–¹å¼ï¼š
- **äº’æ–¥é”**ï¼šæœ€é€šç”¨çš„åŒæ­¥æœºåˆ¶ï¼Œé€‚ç”¨äºå¤§å¤šæ•°åœºæ™¯
- **ä¿¡å·é‡**ï¼šæ§åˆ¶èµ„æºè®¿é—®æ•°é‡
- **æ¡ä»¶å˜é‡**ï¼šçº¿ç¨‹é—´é€šä¿¡å’Œäº‹ä»¶é€šçŸ¥
- **å±éšœ**ï¼šåè°ƒå¤šçº¿ç¨‹æ‰§è¡Œé¡ºåº
- **è¯»å†™é”**ï¼šä¼˜åŒ–è¯»å¤šå†™å°‘åœºæ™¯çš„æ€§èƒ½
- **è‡ªæ—‹é”**ï¼šé¿å…ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€
- **åŸå­æ“ä½œ**ï¼šæ— é”åŒæ­¥ï¼Œé«˜æ€§èƒ½
ç†è§£è¿™äº›åŒæ­¥æœºåˆ¶çš„åŸç†å’Œé€‚ç”¨åœºæ™¯ï¼Œæ˜¯ç¼–å†™é«˜æ•ˆã€å®‰å…¨çš„å¤šçº¿ç¨‹ç¨‹åºçš„å…³é”®ã€‚