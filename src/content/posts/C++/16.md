---
title: 16.size_of是在编译期还是在运行期确定
order: 16
description: 详解C++中sizeof运算符的工作原理，探讨其值是在编译期还是运行期确定，以及C89和C99标准下的不同行为
published: '2026-01-23'
image: /assets/images/cpp-logo.webp
tags:
- C++
- 编译过程
- 内存管理
- 运算符
category: C++
---
# 📏 sizeof运算符：编译期还是运行期确定？

## 📖 内容概览

本文详细探讨C++中sizeof运算符的工作原理，分析其值是在编译期还是运行期确定的，结合C89和C99标准的不同行为，通过代码示例演示sizeof的实际表现，并总结sizeof的核心特性和使用注意事项。

## 🎯 核心概念

### ✨ sizeof运算符的定义

根据《C语言程序设计》的描述：
> C语言提供了一个编译时(compile-time) 一元运算符 sizeof，它可以用来计算任一对象的长度。表达式`sizeof 对象`以及`sizeof(类型名)`将返回一个整型值，它等于指定对象或类型占用的存储空间字节数。

### 🔍 编译期与运行期的区别

- **编译期**：程序编译阶段，编译器根据类型信息计算sizeof的值
- **运行期**：程序执行阶段，根据实际运行时数据动态计算

## 🧪 代码示例与分析

### 示例1：基本类型的sizeof

```cpp
#include <stdio.h>

int main() {
    int n = 3;
    printf("%d\n", sizeof(n++));  // 输出：4
    printf("%d\n", n);           // 输出：3
    return 0;
}
```

**分析**：
- `sizeof(n++)`的结果为4，且`n++`没有执行
- 说明sizeof在编译期就确定了结果，不执行表达式

### 示例2：C99动态数组的sizeof

```cpp
// 需在C99标准或更高版本的编译器下编译
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);  // 输入：3
    int arr[n];        // 动态数组（VLA，Variable Length Array）
    
    printf("%d\n", sizeof(arr));  // 输出：12
    printf("%d\n", n);            // 输出：3
    
    return 0;
}
```

**运行结果**（输入3）：
```cpp
12
3
```

**分析**：
- `sizeof(arr)`的结果为12（3*4=12）
- 动态数组的大小由运行时输入确定，因此sizeof(arr)的值也在运行时确定
- 但需要注意：这是C99引入的VLA特性，在C89中不允许

## 📚 标准版本差异

### C89标准
- 不支持动态数组
- sizeof的结果完全在编译期确定
- sizeof的值可以作为常量使用，如数组大小、case标签等

### C99标准
- 引入了动态数组（VLA）
- 对于动态数组，sizeof的结果在运行期确定
- 对于其他类型，sizeof的结果仍在编译期确定

## 💡 关键特性总结

1. **运算符而非函数**：sizeof是一元运算符，不是函数，因此可以省略括号（如`sizeof int`）
2. **不执行表达式**：sizeof内部的表达式不会被执行（如`sizeof(n++)`不会改变n的值）
3. **编译期确定为主**：除了C99动态数组外，sizeof的值都在编译期确定
4. **类型安全**：sizeof根据类型信息计算，不会访问内存，因此是类型安全的
5. **不能求动态分配内存大小**：sizeof无法获取malloc/free或new/delete分配的内存大小

## 📝 结论

- **主要场景**：sizeof的值在**编译期**确定
- **例外情况**：C99引入的**动态数组**（VLA），其sizeof值在**运行期**确定
- **本质**：sizeof是一种**编译期为主**的运算符，用于获取类型或对象的内存大小
- **注意**：sizeof无法获取动态分配内存的实际大小，只能获取类型或静态分配对象的大小

理解sizeof的工作原理，对于编写高效、安全的C++代码至关重要，特别是在内存管理和性能优化方面。