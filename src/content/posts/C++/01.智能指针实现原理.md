---
title: 1.智能指针实现原理
order: 1
description: "详解C++对象构造和析构机制：智能指针，里面的计数器何时会改变"
published: 2026-01-19
image: /assets/images/cpp-logo.webp
tags: [C++, 智能指针]
category: C++
---
# 智能指针实现原理

## 1. 智能指针是一个类

这个类的构造函数中传入一个普通指针，[析构函数](https://so.csdn.net/so/search?q=析构函数&spm=1001.2101.3001.7020)中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。

## 2. 最常用的智能指针

### 2.1 std::auto_ptr

有很多问题。不支持复制（拷贝构造函数）和赋值（operator =），但复制或赋值的时候不会提示出错。因为不能被复制，所以不能被放入容器中。

### 2.2 std::unique_ptr

也不支持复制和赋值，但比 auto_ptr 好，直接赋值会编译出错。实在想赋值的话，需要使用：std::move。
例如：
```cpp
std::unique_ptr<int> p1(new int(5));
std::unique_ptr<int> p2 = p1; // 编译会出错
std::unique_ptr<int> p3 = std::move(p1); // 转移所有权, 现在那块内存归p3所有, p1成为无效的指针.
```
### 2.3 std::shared_ptr

基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。

### 2.4 std::weak_ptr，弱引用

引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。

### 3. 智能指针的实现

下面是一个基于**引用计数**的智能指针的实现，需要实现构造，析构，拷贝构造，=操作符重载，重载*和->操作符。

```cpp
#include <iostream>

template <typename T>
class SmartPointer {
public:
    // 构造函数
    SmartPointer(T* p=0): _ptr(p), _reference_count(new size_t){
        std::cout << "构造函数被调用：SmartPointer(T* p=0)" << std::endl;
        if(p)
            *_reference_count = 1; 
        else
            *_reference_count = 0; 
    }
    
    // 拷贝构造函数
    SmartPointer(const SmartPointer& src) {
        std::cout << "拷贝构造函数被调用：SmartPointer(const SmartPointer& src)" << std::endl;
        if(this != &src) {
            _ptr = src._ptr;
            _reference_count = src._reference_count;
            (*_reference_count)++;
        }
    }
    
    // 重载赋值操作符
    SmartPointer& operator=(const SmartPointer& src) {
        std::cout << "赋值操作符被调用：SmartPointer& operator=(const SmartPointer& src)" << std::endl;
        if(_ptr==src._ptr) {
            return *this;
        }
        releaseCount();
        _ptr = src._ptr;
        _reference_count = src._reference_count;
        (*_reference_count)++;
        return *this;
    }
 
    // 重载*操作符
    T& operator*() {
        std::cout << "operator*被调用：T& operator*()" << std::endl;
        if(_ptr) {
            return *_ptr;
        }
        // throw exception
    }
    
    // 重载->操作符
    T* operator->() {
        std::cout << "operator->被调用：T* operator->()" << std::endl;
        if(_ptr) {
            return _ptr;
        }
        // throw exception
    }
    
    // 析构函数
    ~SmartPointer() {
        std::cout << "析构函数被调用：~SmartPointer()" << std::endl;
        if (--(*_reference_count) == 0) {
            delete _ptr;
            delete _reference_count;
        }
    }
    
private:
    T *_ptr;
    size_t *_reference_count;
    
    // 释放引用计数
    void releaseCount() {
        std::cout << "releaseCount函数被调用：void releaseCount()" << std::endl;
        if(_ptr) {
            (*_reference_count)--;
            if((*_reference_count)==0) {
                delete _ptr;
                delete _reference_count;
            }
        }
    }
};

int main() 
{
    std::cout << "主函数被调用：main function called" << std::endl;
    
    std::cout << "------SmartPointer<char> cp1(new char('a'))" << std::endl;
    SmartPointer<char> cp1(new char('a'));
    
    std::cout << "------SmartPointer<char> cp2(cp1)" << std::endl;
    SmartPointer<char> cp2(cp1);
    
    std::cout << "------SmartPointer<char> cp3" << std::endl;
    SmartPointer<char> cp3;
    
    std::cout << "------cp3 = cp2" << std::endl;
    cp3 = cp2;
    
    std::cout << "------cp3 = cp1" << std::endl;
    cp3 = cp1;
    
    std::cout << "------cp3 = cp3" << std::endl;
    cp3 = cp3;
    
    std::cout << "------SmartPointer<char> cp4(new char('b'))" << std::endl;
    SmartPointer<char> cp4(new char('b'));
    
    std::cout << "------cp3 = cp4" << std::endl;
    cp3 = cp4;
    
    std::cout << "主函数结束：main function ending" << std::endl;
    return 0;
}
```

运行结果：

```cmd
E:\MyGithubPro\GStudyCodes\c-cpp-tests>g++ -o 智能指针 智能指针.cpp
E:\MyGithubPro\GStudyCodes\c-cpp-tests>智能指针
主函数被调用：main function called
------SmartPointer<char> cp1(new char('a'))
构造函数被调用：SmartPointer(T* p=0)
------SmartPointer<char> cp2(cp1)
拷贝构造函数被调用：SmartPointer(const SmartPointer& src)
------SmartPointer<char> cp3
构造函数被调用：SmartPointer(T* p=0)
------cp3 = cp2
赋值操作符被调用：SmartPointer& operator=(const SmartPointer& src)
releaseCount函数被调用：void releaseCount()
------cp3 = cp1
赋值操作符被调用：SmartPointer& operator=(const SmartPointer& src)
------cp3 = cp3
赋值操作符被调用：SmartPointer& operator=(const SmartPointer& src)
------SmartPointer<char> cp4(new char('b'))
构造函数被调用：SmartPointer(T* p=0)
------cp3 = cp4
赋值操作符被调用：SmartPointer& operator=(const SmartPointer& src)
releaseCount函数被调用：void releaseCount()
主函数结束：main function ending
析构函数被调用：~SmartPointer()
析构函数被调用：~SmartPointer()
析构函数被调用：~SmartPointer()
析构函数被调用：~SmartPointer()
```

### 4. 代码执行详细分析

为了更直观地理解智能指针的工作原理，我们详细分析每一步的执行过程和引用计数变化：

#### 4.1 执行流程表

为了更直观地展示智能指针的执行过程，我们使用表格形式来表示：

| 序号 | 执行代码 | 调用函数 | char('a')内存引用计数 | char('b')内存引用计数 | 详细说明 |
|:----:|:---------|:----------|:---------------------:|:---------------------:|:---------|
| 1 | `SmartPointer<char> cp1(new char('a'));` | 构造函数 | 1 | - | 创建cp1，初始化char('a')内存，引用计数=1 |
| 2 | `SmartPointer<char> cp2(cp1);` | 拷贝构造函数 | 2 | - | 创建cp2，拷贝cp1，共享内存，引用计数=2 |
| 3 | `SmartPointer<char> cp3;` | 构造函数 | 2 | - | 创建cp3，空指针，引用计数=0 |
| 4 | `cp3 = cp2;` | 赋值操作符 | 3 | - | cp3赋值为cp2，指向相同内存，引用计数=3 |
| 5 | `cp3 = cp2;` (续) | releaseCount | 3 | - | 释放cp3原来的内存（无） |
| 6 | `cp3 = cp1;` | 赋值操作符 | 3 | - | cp3赋值为cp1，仍指向相同内存，引用计数=3 |
| 7 | `cp3 = cp1;` (续) | releaseCount | 3 | - | 释放cp3原来的内存，引用计数不变 |
| 8 | `cp3 = cp3;` | 赋值操作符 | 3 | - | cp3自我赋值，由于指针相同，直接返回，引用计数不变 |
| 9 | `SmartPointer<char> cp4(new char('b'));` | 构造函数 | 3 | 1 | 创建cp4，新内存char('b')，引用计数=1 |
| 10 | `cp3 = cp4;` | 赋值操作符 | 3 | 2 | cp3赋值为cp4，指向char('b')内存，char('b')引用计数=2 |
| 11 | `cp3 = cp4;` (续) | releaseCount | 2 | 2 | 释放cp3原来指向的char('a')内存，char('a')引用计数减1 |
| 12 | 析构cp4 | 析构函数 | 2 | 1 | 析构cp4，char('b')引用计数减1 |
| 13 | 析构cp3 | 析构函数 | 2 | 0 | 析构cp3，char('b')引用计数减1至0，释放char('b')内存 |
| 14 | 析构cp2 | 析构函数 | 1 | - | 析构cp2，char('a')引用计数减1 |
| 15 | 析构cp1 | 析构函数 | 0 | - | 析构cp1，char('a')引用计数减1至0，释放char('a')内存 |

#### 4.2 关键函数调用分析

##### 1. 构造函数

- **调用时机**：当创建新的智能指针对象时
- **参数**：可以是指向T类型的指针或默认值nullptr
- **作用**：
  - 初始化指针成员`_ptr`指向实际内存
  - 初始化引用计数`_reference_count`为1（如果有实际内存）或0（nullptr）

##### 2. 拷贝构造函数

- **调用时机**：当用一个智能指针对象初始化另一个新对象时
- **参数**：const引用的源智能指针
- **作用**：
  - 共享源对象的内存指针`_ptr`
  - 共享源对象的引用计数`_reference_count`
  - 将引用计数加1

##### 3. 赋值操作符

- **调用时机**：当用一个智能指针对象赋值给另一个已存在的对象时
- **参数**：const引用的源智能指针
- **作用**：
  - 检查自我赋值，避免不必要的操作
  - 调用`releaseCount()`释放当前对象原来指向的内存
  - 共享源对象的内存指针和引用计数
  - 将引用计数加1

##### 4. releaseCount函数

- **调用时机**：在赋值操作符中，当当前对象需要释放原来指向的内存时
- **作用**：
  - 将引用计数减1
  - 如果引用计数变为0，释放实际内存和引用计数内存

##### 5. 析构函数

- **调用时机**：当智能指针对象离开作用域时
- **作用**：
  - 将引用计数减1
  - 如果引用计数变为0，释放实际内存和引用计数内存

#### 4.3 智能指针核心设计思想

1. **引用计数机制**：
   - 所有指向同一内存的智能指针共享一个引用计数
   - 每次拷贝或赋值时，引用计数加1
   - 每次析构或赋值新值时，引用计数减1
   - 当引用计数为0时，自动释放内存

2. **RAII原则**：
   - Resource Acquisition Is Initialization
   - 资源获取即初始化，资源释放即销毁
   - 智能指针对象在栈上创建，离开作用域时自动调用析构函数

3. **防止内存泄漏**：
   - 确保动态分配的内存都能被正确释放
   - 即使程序发生异常，栈上的智能指针对象也会被正确析构

4. **安全的赋值操作**：
   - 处理了自我赋值的情况
   - 正确释放旧内存，再获取新内存的引用

### 小结

通过对智能指针实现原理的深入分析，我们可以看到其核心在于**引用计数机制**和**RAII原则**的结合。这种设计不仅保证了内存的自动管理，还有效地防止了内存泄漏和悬空指针等问题。智能指针是现代C++编程中不可或缺的重要组成部分，为我们编写安全、高效的代码提供了强有力的保障。

通过以上详细分析，我们可以清晰地理解智能指针的工作原理、函数调用时机以及引用计数的变化过程。这种设计模式能够有效避免内存泄漏，提高C++程序的安全性和可靠性。