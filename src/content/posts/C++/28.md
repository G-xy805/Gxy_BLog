---
title: 28.函数参数可不可以传右值
order: 28
description: 详解C++函数参数传递右值的原理、方法和最佳实践，包括右值引用参数和值传递的对比分析
published: '2026-01-23'
image: /assets/images/cpp-logo.webp
tags:
- C++
- 右值引用
- 函数参数
- 性能优化
category: C++
---
# 🔬 函数参数可不可以传右值
## 📖 内容概览

## 🎯 核心概念

## 🔄 功能详解

## ⚠️ ⚠️ ⚠️ ⚠️ ⚠️ ⚠️ 注意事项

## 💡 关键要点

## 📋 总结


📖 **内容概览**
- 函数参数传递右值的基本概念
- 右值引用参数的语法和使用场景
- 值传递与右值引用参数的性能对比
- 不同场景下的函数参数传递最佳实践
- 函数参数传递右值的注意事项

🎯 **核心概念**

### 函数参数传递右值的可能性

在C++11引入右值引用后，函数参数**完全可以传递右值**，并且有多种方式实现：

1. **使用右值引用参数**（`T&&`）：专门用于接收右值
2. **使用常量左值引用参数**（`const T&`）：可以同时接收左值和右值
3. **使用值传递参数**（`T`）：可以通过移动构造函数接收右值

### 右值引用参数的典型应用场景

右值引用参数最典型的应用场景是：**当函数需要复制参数，并且复制结果需要存储在函数栈帧之外**。

最常见的例子是STL容器的添加元素操作，如`vector::push_back`，它提供了两个重载版本：
- `void push_back(const T& value)`：接收左值，执行拷贝操作
- `void push_back(T&& value)`：接收右值，执行移动操作

### 值传递与引用传递的性能对比

| 参数传递方式 | 左值实参时的操作 | 右值实参时的操作 | 适用场景 |
|--------------|------------------|------------------|----------|
| `const T&`   | 一次拷贝         | 一次拷贝         | 不需要修改参数，且拷贝代价较低 |
| `T&&`        | 编译错误         | 一次移动         | 只接收右值，需要高效移动 |
| `T`          | 一次拷贝         | 一次移动         | 函数内部需要修改参数副本 |

💻 **代码示例**

### 1. 右值引用参数的基本使用

```cpp
#include <iostream>
#include <vector>
#include <string>

// 模拟vector的push_back实现
template <typename T>
class MyVector {
public:
    // 左值引用版本：用于接收左值
    void push_back(const T& value) {
        std::cout << "调用左值引用版本push_back，执行拷贝操作" << std::endl;
        // 实际实现中会拷贝value到容器
    }
    
    // 右值引用版本：用于接收右值
    void push_back(T&& value) {
        std::cout << "调用右值引用版本push_back，执行移动操作" << std::endl;
        // 实际实现中会移动value到容器
    }
};

class MyClass {
public:
    MyClass() { std::cout << "默认构造函数" << std::endl; }
    MyClass(const MyClass&) { std::cout << "拷贝构造函数" << std::endl; }
    MyClass(MyClass&&) noexcept { std::cout << "移动构造函数" << std::endl; }
};

int main() {
    MyVector<MyClass> vec;
    
    MyClass obj;  // 创建左值对象
    vec.push_back(obj);  // 调用左值引用版本
    
    std::cout << "---" << std::endl;
    
    vec.push_back(MyClass());  // 调用右值引用版本，传递临时对象
    vec.push_back(std::move(obj));  // 调用右值引用版本，通过std::move转换左值
    
    return 0;
}
```

### 2. 值传递与引用传递的对比

```cpp
#include <iostream>
#include <string>

class HeavyObject {
public:
    HeavyObject() : data(new int[1000000]) { std::cout << "默认构造" << std::endl; }
    
    // 拷贝构造函数：代价高
    HeavyObject(const HeavyObject& other) : data(new int[1000000]) {
        std::cout << "拷贝构造 - 代价高操作" << std::endl;
        std::copy(other.data, other.data + 1000000, data);
    }
    
    // 移动构造函数：代价低
    HeavyObject(HeavyObject&& other) noexcept : data(other.data) {
        std::cout << "移动构造 - 代价低操作" << std::endl;
        other.data = nullptr;
    }
    
    ~HeavyObject() { delete[] data; }
    
private:
    int* data;
};

// 函数1：使用const左值引用参数
void func1(const HeavyObject& obj) {
    std::cout << "func1: 接收const引用，内部需要拷贝" << std::endl;
    HeavyObject local = obj;  // 拷贝构造
    // 使用local...
}

// 函数2：使用值传递参数
void func2(HeavyObject obj) {
    std::cout << "func2: 接收值传递，直接使用参数" << std::endl;
    // 使用obj...
}

int main() {
    HeavyObject obj;
    
    std::cout << "\n--- 调用func1(obj)（左值实参）---" << std::endl;
    func1(obj);  // 一次拷贝构造
    
    std::cout << "\n--- 调用func2(obj)（左值实参）---" << std::endl;
    func2(obj);  // 一次拷贝构造
    
    std::cout << "\n--- 调用func1(HeavyObject())（右值实参）---" << std::endl;
    func1(HeavyObject());  // 一次拷贝构造
    
    std::cout << "\n--- 调用func2(HeavyObject())（右值实参）---" << std::endl;
    func2(HeavyObject());  // 一次移动构造
    
    return 0;
}
```

### 3. 构造函数中的参数传递最佳实践

```cpp
#include <string>

class MyClass {
private:
    std::string str_member;
    
public:
    // 方式1：传统的const左值引用参数
    MyClass(const std::string& str) : str_member(str) {
        // 无论实参是左值还是右值，都执行一次拷贝
    }
    
    // 方式2：现代的值传递 + move方式
    MyClass(std::string str) : str_member(std::move(str)) {
        // 左值实参：一次拷贝 + 一次move
        // 右值实参：两次move
    }
};
```

## 📌 函数参数传递右值的最佳实践

### 场景1：函数内部需要修改参数副本

如果函数内部需要修改参数的副本，考虑使用**值传递**：
- 对于左值实参：一次拷贝构造
- 对于右值实参：一次移动构造

```cpp
void process_and_store(HeavyObject obj) {
    // 修改obj...
    storage.push_back(std::move(obj));
}
```

### 场景2：函数内部不需要修改参数，也不需要拷贝

如果函数内部既不需要修改参数，也不需要拷贝参数，使用**常量左值引用**：

```cpp
void print_info(const HeavyObject& obj) {
    // 只读取obj的信息，不修改也不拷贝
    std::cout << obj.get_info() << std::endl;
}
```

### 场景3：函数需要将参数存储到外部

如果函数需要将参数存储到外部（如容器、成员变量等），考虑提供**两个重载版本**：

```cpp
// 左值版本：拷贝
void add_to_container(const T& value) {
    container.push_back(value);  // 拷贝
}

// 右值版本：移动
void add_to_container(T&& value) {
    container.push_back(std::move(value));  // 移动
}
```

### 场景4：构造函数参数传递

对于构造函数，需要根据成员变量的类型和拷贝/移动代价选择合适的参数传递方式：

```cpp
// 对于小型对象（如int、double、小字符串）
class SmallObject {
public:
    SmallObject(int value) : value_(value) {}  // 直接值传递
    
private:
    int value_;
};

// 对于大型对象
class LargeObject {
public:
    // 方式1：两个重载版本
    LargeObject(const std::string& name) : name_(name) {}  // 拷贝
    LargeObject(std::string&& name) : name_(std::move(name)) {}  // 移动
    
    // 方式2：值传递 + move（现代C++常用）
    LargeObject(std::string name) : name_(std::move(name)) {}  // 一次拷贝或一次移动
    
private:
    std::string name_;
};
```

📋 **总结与最佳实践**

1. **函数参数可以传递右值**，并且有多种实现方式
2. **右值引用参数**适用于需要高效移动资源的场景
3. **值传递**在函数内部需要修改参数副本时表现良好
4. **常量左值引用**适用于不需要修改参数的场景
5. **移动操作并非总是比拷贝操作高效**：
   - 对于小型对象（如int、double），拷贝操作可能比移动操作更高效
   - 对于std::string等具有SSO（小字符串优化）的类型，拷贝小字符串可能比移动更高效
   - 对于需要深拷贝的大型对象，移动操作优势明显

6. **构造函数参数传递建议**：
   - 对于小型对象，直接使用值传递
   - 对于大型对象，考虑使用值传递+move的方式，或提供两个重载版本
   - 根据实际性能测试结果选择最优方案

7. **避免过度优化**：
   - 优先考虑代码的可读性和维护性
   - 只有在性能瓶颈明确时才进行优化
   - 使用性能分析工具验证优化效果

函数参数传递右值是现代C++中的重要特性，合理使用可以显著提高程序性能。但需要根据具体场景选择合适的参数传递方式，避免盲目追求"最先进"的语法而忽略实际性能表现。