---
title: 4.面向对象的特性：多态原理
order: 4
description: "详解C++面向对象编程中多态的实现原理，包括虚函数表的工作机制、如何通过虚表实现动态绑定，以及多态的三个必要条件。"
published: 2026-01-21
image: /assets/images/cpp-logo.webp
tags: [C++, 多态, 面向对象, 虚函数表, 动态绑定, 继承, 虚函数, 底层实现]
category: C++
---
# 面向对象的特性：**多态**原理

## 1.原理介绍

多态可以让同名函数，因为函数指向对象的不同，而去调用该对象中该名称的函数。
其实底层就是因为虚表的一些神奇操作。
操作系统为构成多态的每个类增加了一个虚函数表。这个虚函数表中存放的就是virtual关键词修饰的虚函数的首地址。编译器运行的时候通过虚表中存储的函数首地址去调用对应的函数。从而达到我们多态的目的。

## 2.验证虚表的存在

打印两个一模一样的类的大小
一个实现多态，一个没有实现。

```c++
#include <iostream>

namespace test1 {
	// 求一个正常的class大小
	class Person {
	public:
		void test() {}
	private:
		int m_a;
	};

	class Student {
	public:
		virtual void test() {}
	private:
		int m_a;
	};
	
	void mytest() {
		Person s1;
		Student s2;
		std::cout << "Person size: " << sizeof(s1) << std::endl;
		std::cout << "Student size: " << sizeof(s2) << std::endl;
	}
	// 求一个有虚表的class的大小
}

int main() {
	test1::mytest();
	return 0;
}
```

运行结果：
我们发现实现多态的类比没实现的大四个字节（一个指针大小）

```cmd
E:\MyGithubPro\GStudyCodes\c-cpp-tests>g++ -o 虚表 虚表.cpp
E:\MyGithubPro\GStudyCodes\c-cpp-tests>虚表
Person size: 4
Student size: 16
```
## 3.对虚表中存储的函数地址进行打印

虚函数表本质是一个存虚函数指针的指针数组，这个数组最后面放了一个nullptr。利用这个特性我们进行类型强转，于是可以打印出这个续表中存储的各个函数指针的数值。

```c++
namespace test8 {
	//student 继承person 打印出指针 深入验证虚表存储的是什么
	class Person {
	public:
		virtual void Example1() {
			std::cout << "pex1" << std::endl;
		}
		virtual void Example2() {
			std::cout << "pex2" << std::endl;
		}
		virtual void Example3() {
			std::cout << "pex3" << std::endl;
		}
		virtual void Example4() {
			std::cout << "pex4" << std::endl;
		}
	private:
		int _a;
	};
	class Student : public Person {
	public:
		virtual void Example1() {
			std::cout << "sex1" << std::endl;
		}
		virtual void Example2() {
			std::cout << "sex2" << std::endl;
		}
		virtual void Example3() {
			std::cout << "sex3" << std::endl;
		}
		virtual void Example5() {
			std::cout << "sex5" << std::endl;
		}
	private:
		int _b;
	};

	typedef void(*VFPTR) ();
	void MyPrint(VFPTR vTable[])
	{
		// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数
		std::cout << " 虚表地址>" << vTable << std::endl;
	
		for (int i = 0; vTable[i] != nullptr; ++i)
		{
			printf(" 第%d个虚函数地址 :0X%x,->", i, vTable[i]);
			VFPTR f = vTable[i];
			f();
		}
		std::cout << std::endl;
	}
	int mytest() {
		Person s1;
		Student s2;
		//打印出虚函数表的数值
		VFPTR* vTableb = (VFPTR*)(*(int*)&s1);
		MyPrint(vTableb);
		VFPTR* vTabled = (VFPTR*)(*(int*)&s2);
		MyPrint(vTabled);
		return 0;
	}

};
```

运行结果：
于是发现，父子类中都有一张虚表，用来存放虚函数的地址，子类重写了父类中的虚函数时，子类的虚表会指向新的地址，该地址是存放重写的虚函数的。（函数都在代码段）
当没有重写时候，父子的虚表都指向同一个地址。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612180442942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lmd2VjYW5kZQ==,size_16,color_FFFFFF,t_70)

## 4.单继承和多继承的虚函数表

单继承的虚表如上面所示，父子类各有一张。而出现多继承的时候，子类中就会存在1张虚表包含了n个父类虚表的虚表，每张虚表都来自于不同的父类。
**代码所示：**

```c++
using namespace std;
namespace test9 {
	class Base1 {
	public:
		virtual void func1() { cout << "Base1::func1" << endl; }
		virtual void func2() { cout << "Base1::func2" << endl; }
	private:
		int b1;
	};
	class Base2 {
	public:
		virtual void func1() { cout << "Base2::func1" << endl; }
		virtual void func2() { cout << "Base2::func2" << endl; }
	private:
		int b2;
	};
	class Derive : public Base1, public Base2 {
	public:
		virtual void func1() { cout << "Derive::func1" << endl; }
		virtual void func3() { cout << "Derive::func3" << endl; }
	private:
		int d1;
	};
	typedef void(*VFPTR) ();
	void PrintVTable(VFPTR vTable[])
	{
		cout << " 虚表地址>" << vTable << endl;
		for (int i = 0; vTable[i] != nullptr; ++i)
		{
			printf(" 第%d个虚函数地址 :0X%x,->", i, vTable[i]);
			VFPTR f = vTable[i];
			f();
		}
		cout << endl;
	}
	void mytest()
	{
		Derive d;
		VFPTR* vTableb1 = (VFPTR*)(*(int*)&d);
		PrintVTable(vTableb1);
		VFPTR* vTableb2 = (VFPTR*)(*(int*)((char*)&d + sizeof(Base1)));
		PrintVTable(vTableb2);
	}
};
```

**运行结果：**
先继承的类虚表在前面，后继承的类的虚表在后边。
子类中父类没有的虚函数会默认放在第一张虚表中。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200612181540388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lmd2VjYW5kZQ==,size_16,color_FFFFFF,t_70)

## 5.结构总结

**对于一个普通的A类**
内存布局为：函数存在数据段（类成员共享）成员变量存在栈（由具体情况而定）
一般情况下，类大小计算只需要考虑成员变量

```c++
class A{
void func(){}
int a};
```


对于一个内部存在虚函数的B类

```c++
class B{
virtual void func(){}
int b};
```


内存布局为：函数存在数据段（类成员共享）成员变量存在栈（由具体情况而定），但是在类的起始位置会存在一个虚表指针（4/8字节）， 指向虚函数表所在位置。
计算时需要额外考虑虚表指针。
**多继承时的内存布局**
C继承A，又继承B，在C的内存布局中，会按照先后顺序进行数据的存放， A前B后，A开始位置是A的虚表指针， B的开始位置是B的虚表指针，C中就有多个虚表。

**与虚继承对比**
虚继承解决了多继承产生的菱形继承问题，底层实际是产生数据冗余和二义性的地方不存储对应数据，而是选择存储一个指向虚基表的指针，通过虚基表中的偏移量来找到对应的数据。
多态实现了，一个对象指向谁调用谁。底层是在类的起始位置存储了一个虚函数表地址，当程序运行起来时，通过在虚函数表中查找对应的函数，来实现指向谁调用谁。