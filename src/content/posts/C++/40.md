---
title: 40.友元friend介绍
order: 40
description: 详解C++友元机制，包括友元函数和友元类的概念、用法及注意事项
published: '2026-01-23'
image: /assets/images/cpp-logo.webp
tags:
- C++
- 友元
- 面向对象
- 封装
- 类
category: C++
---
# 🔬 友元friend介绍
## 📖 内容概览

## 🎯 核心概念

## 🔄 功能详解

## ⚠️ ⚠️ ⚠️ ⚠️ ⚠️ ⚠️ 注意事项

## 💡 关键要点

## 📋 总结


📖 内容概览

本文详细介绍C++中的友元机制，包括友元函数和友元类的概念、语法、使用场景及注意事项。友元机制允许特定的外部函数或类访问类的私有成员，在提高程序效率的同时，也带来了封装性的挑战。通过本文的学习，读者将深入理解友元的工作原理和最佳实践。

🎯 核心概念

## 🎯 1. 友元的基本概念

友元是C++面向对象编程中的一种特殊机制，它允许外部函数或类访问另一个类的私有成员和保护成员，打破了类的封装性，提供了一种灵活的访问方式。

### 1.1 友元的作用

- **提高程序效率**：减少了类型检查和安全性检查的时间开销
- **提供灵活的访问方式**：允许特定的外部实体访问类的内部成员
- **方便设计模式的实现**：某些设计模式（如观察者模式）需要友元机制支持

### 1.2 友元的种类

- **友元函数**：非成员函数可以访问类的私有成员
- **友元类**：整个类的所有成员函数都可以访问另一个类的私有成员

## 📌 2. 友元函数

友元函数是定义在类外的普通函数，但在类的声明中被声明为友元，因此可以访问类的私有成员和保护成员。

### 2.1 友元函数的声明

```cpp
class ClassName {
    // 友元函数声明，可以放在public、private或protected区域
    friend ReturnType FunctionName(ParameterList);
};
```

### 2.2 友元函数的定义

友元函数在类外定义，不需要使用类作用域解析符`::`：

```cpp
ReturnType FunctionName(ParameterList) {
    // 可以直接访问类的私有成员
}
```

### 2.3 友元函数的特点

1. 友元函数不是类的成员函数
2. 友元函数可以访问类的私有成员和保护成员
3. 友元函数的声明位置不影响其访问权限
4. 一个函数可以是多个类的友元函数
5. 友元函数的调用方式与普通函数相同

## 📌 3. 友元类

友元类是指一个类的所有成员函数都可以访问另一个类的私有成员和保护成员。

### 3.1 友元类的声明

```cpp
class ClassA {
    friend class ClassB;  // 声明ClassB为ClassA的友元类
};
```

### 3.2 友元类的特点

1. 友元关系不能被继承
2. 友元关系是单向的，不具有交换性
3. 友元关系不具有传递性
4. 友元类的所有成员函数都是另一个类的友元函数

💻 代码示例

### 1. 友元函数示例

```cpp
#include <iostream>
#include <cmath>
using namespace std;

class Point {
public:
    // 构造函数
    Point(double xx, double yy) : x(xx), y(yy) {}
    
    // 公有成员函数
    void Getxy() {
        cout << "(" << x << ", " << y << ")" << endl;
    }
    
    // 声明友元函数
    friend double Distance(Point &a, Point &b);
    
private:
    double x, y;  // 私有成员
};

// 友元函数定义，无需类作用域解析符
double Distance(Point &a, Point &b) {
    double dx = a.x - b.x;  // 直接访问私有成员
    double dy = a.y - b.y;  // 直接访问私有成员
    return sqrt(dx * dx + dy * dy);
}

int main() {
    Point p1(3.0, 4.0), p2(6.0, 8.0);
    p1.Getxy();
    p2.Getxy();
    
    double d = Distance(p1, p2);  // 调用友元函数
    cout << "Distance is " << d << endl;
    
    return 0;
}
```

### 2. 友元类示例

```cpp
#include <iostream>
using namespace std;

// 前向声明
class ClassB;

class ClassA {
private:
    int privateMemberA;
    
public:
    ClassA() : privateMemberA(10) {}
    
    // 声明ClassB为友元类
    friend class ClassB;
    
    void Show() {
        cout << "ClassA::privateMemberA = " << privateMemberA << endl;
    }
};

class ClassB {
private:
    int privateMemberB;
    
public:
    ClassB() : privateMemberB(20) {}
    
    // 访问ClassA的私有成员
    void AccessClassA(ClassA &a) {
        cout << "ClassB accessing ClassA::privateMemberA: " << a.privateMemberA << endl;
        a.privateMemberA = 100;  // 修改ClassA的私有成员
    }
};

int main() {
    ClassA a;
    ClassB b;
    
    a.Show();
    b.AccessClassA(a);  // ClassB可以访问ClassA的私有成员
    a.Show();  // 验证ClassA的私有成员被修改
    
    return 0;
}
```

### 3. 多个类的友元函数示例

```cpp
#include <iostream>
using namespace std;

class ClassB;

class ClassA {
private:
    int valueA;
    
public:
    ClassA(int v) : valueA(v) {}
    friend void Compare(ClassA &a, ClassB &b);  // 友元函数声明
};

class ClassB {
private:
    int valueB;
    
public:
    ClassB(int v) : valueB(v) {}
    friend void Compare(ClassA &a, ClassB &b);  // 同一个函数也是ClassB的友元
};

// 友元函数可以访问两个类的私有成员
void Compare(ClassA &a, ClassB &b) {
    if (a.valueA > b.valueB) {
        cout << "ClassA's value is larger" << endl;
    } else if (a.valueA < b.valueB) {
        cout << "ClassB's value is larger" << endl;
    } else {
        cout << "Values are equal" << endl;
    }
}

int main() {
    ClassA a(15);
    ClassB b(20);
    Compare(a, b);  // 调用友元函数
    
    return 0;
}
```

⚠️ 注意事项

1. **破坏封装性**：友元机制打破了类的封装性，应谨慎使用
2. **友元关系的单向性**：
   - 若ClassB是ClassA的友元，ClassA不一定是ClassB的友元
   - 友元关系不会自动反向
3. **友元关系不可继承**：
   - 友元关系不会被子类继承
   - 子类不会自动获得父类的友元关系
4. **友元关系无传递性**：
   - 若ClassB是ClassA的友元，ClassC是ClassB的友元，ClassC不一定是ClassA的友元
   - 需要显式声明友元关系
5. **友元函数的定义位置**：
   - 友元函数在类外定义，不需要类作用域解析符
   - 友元函数可以在多个类中声明
6. **友元的声明位置**：
   - 友元声明可以放在类的public、private或protected区域
   - 声明位置不影响友元的访问权限

📚 总结与最佳实践

### 1. 友元的优缺点

| 优点 | 缺点 |
|------|------|
| 提高程序效率 | 破坏类的封装性 |
| 提供灵活的访问方式 | 降低代码的可维护性 |
| 方便某些设计模式的实现 | 增加了类之间的耦合度 |
| 简化代码实现 | 可能导致意外的副作用 |

### 2. 友元的使用场景

- **运算符重载**：如`<<`和`>>`运算符重载需要访问类的私有成员
- **设计模式实现**：如观察者模式、工厂模式等
- **测试代码**：单元测试中需要访问类的私有成员
- **性能关键路径**：在性能要求高的场景下减少函数调用开销

### 3. 友元的最佳实践

1. **最小化友元使用**：仅在必要时使用友元，尽量保持类的封装性
2. **明确友元关系**：清晰地记录友元关系，便于代码维护
3. **避免循环友元**：防止类之间形成复杂的依赖关系
4. **优先使用成员函数**：能使用成员函数解决的问题，尽量不使用友元
5. **使用友元类时谨慎**：友元类的所有成员函数都能访问私有成员，风险较大
6. **考虑替代方案**：如使用访问器函数（getter/setter）、重构类结构等

### 4. 友元与封装性的平衡

- **封装性是面向对象的核心原则**：友元机制是对封装性的一种妥协
- **合理使用友元**：在提高效率和保持封装性之间找到平衡
- **良好的设计**：通过合理的类设计减少对友元的需求

### 5. 常见误区

- **友元函数是类的成员函数**：错误，友元函数不是类的成员函数
- **友元关系具有传递性**：错误，友元关系不具有传递性
- **友元关系可以被继承**：错误，友元关系不能被继承
- **友元声明只能放在public区域**：错误，友元声明可以放在任何访问控制区域

通过合理使用友元机制，可以在保持代码封装性的同时，提高程序的效率和灵活性。在实际开发中，应根据具体需求权衡使用友元的利弊，遵循最佳实践，编写高质量的C++代码。